package lang.Thread.Thread01;

/*
 *	进程：
 *		正在运行的程序，是系统进行资源分配和调用的独立单位。
 *		每一个进程都有它自己的内存空间和系统资源。
 *	线程：
 *		是进程中的单个顺序控制流，是一条执行路径
 *		一个进程如果只有一条执行路径，则称为单线程程序。
 *		一个进程如果有多条执行路径，则称为多线程程序。
 *
 *  举例：
 *  	扫雷程序，迅雷下载
 *  
 *  大家注意两个词汇的区别：并行和并发。
 *		前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。
 *		后者是物理上同时发生，指在某一个时间点同时运行多个程序。
 *
 * Java程序的运行原理：
 * 		由java命令启动JVM，JVM启动就相当于启动了一个进程。
 * 		接着有该进程创建了一个主线程去调用main方法。
 * 
 * 思考题：
 * 		jvm虚拟机的启动是单线程的还是多线程的?
 * 			多线程的。
 * 			原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。
 * 			现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。
 */
/*
 * 需求：我们要实现多线程的程序。
 * 如何实现呢?
 * 		由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。
 * 		而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。
 * 		Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。
 * 		但是呢?Java可以去调用C/C++写好的程序来实现多线程程序。
 * 		由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，
 * 		然后提供一些类供我们使用。我们就可以实现多线程程序了。
 * 那么Java提供的类是什么呢?
 * 		Thread
 * 		通过查看API，我们知道了有2种方式实现多线程程序。
 * 
 * 方式1：继承Thread类。
 * 步骤
 * 		A:自定义类MyThread继承Thread类。
 * 		B:MyThread类里面重写run()?
 * 			为什么是run()方法呢?
 * 		C:创建对象
 * 		D:启动线程
 */
public class MyThreadDemo {
	public static void main(String[] args) {
		// 创建线程对象
		// MyThread my = new MyThread();
		// // 启动线程
		// my.run();
		// my.run();
		// 调用run()方法为什么是单线程的呢?
		// 因为run()方法直接调用其实就相当于普通的方法调用,所以你看到的是单线程的效果
		// 要想看到多线程的效果，就必须说说另一个方法：start()
		// 面试题：run()和start()的区别?
		// run():仅仅是封装被线程执行的代码，直接调用是普通方法
		// start():首先启动了线程，然后再由jvm去调用该线程的run()方法。
		// MyThread my = new MyThread();
		// my.start();
		// // IllegalThreadStateException:非法的线程状态异常
		// // 为什么呢?因为这个相当于是my线程被调用了两次。而不是两个线程启动。
		// my.start();

		// 创建两个线程对象
		MyThread mt1 = new MyThread();
		MyThread mt2 = new MyThread();

		mt1.start();
		mt2.start();
	}
}
